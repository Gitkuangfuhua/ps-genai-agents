server_uri: neo4j://localhost:7687/
admin_user: neo4j
admin_pass: neo4j123

# database: synthea100
# data_directory: /Users/henrylin/dev/patient-journey-model/import/synthea100
# data_version: v2

# database: synthea1k
# data_directory: /Users/henrylin/dev/patient-journey-model/import/synthea1k
# data_version: v2

database: coherent
data_directory: /Users/henrylin/dev/patient-journey-model/import/coherent20221107/csv
data_version: v1

# database: synthea100def
# data_directory: /Users/henrylin/dev/patient-journey-model/import/synthea100def/csv
# data_version: v2

# add unique constraint
pre_ingest:
  - CREATE CONSTRAINT constraint_encounter_id IF NOT EXISTS FOR (n:Encounter) REQUIRE n.id IS UNIQUE
  - CREATE INDEX IF NOT EXISTS FOR (n:Encounter) ON (n.date)
  - CREATE INDEX IF NOT EXISTS FOR (n:Encounter) ON (n.isEnd)
  - CREATE CONSTRAINT constraint_encounterEnd_id IF NOT EXISTS FOR (n:EncounterEnd) REQUIRE n.id IS UNIQUE
  - CREATE INDEX IF NOT EXISTS FOR (n:EncounterEnd) ON (n.date)
  - CREATE INDEX IF NOT EXISTS FOR (n:EncounterEnd) ON (n.isEnd)
  - CREATE CONSTRAINT constraint_Patient_id IF NOT EXISTS FOR (n:Patient) REQUIRE n.id IS UNIQUE
  - CREATE CONSTRAINT constraint_Provider_id IF NOT EXISTS FOR (n:Provider) REQUIRE n.id IS UNIQUE
  - CREATE CONSTRAINT constraint_Payer_id IF NOT EXISTS FOR (n:Payer) REQUIRE n.id IS UNIQUE
  - CREATE CONSTRAINT constraint_Organization_id IF NOT EXISTS FOR (n:Organization) REQUIRE n.id IS UNIQUE
  - CREATE CONSTRAINT constraint_Drug_id IF NOT EXISTS FOR (n:Drug) REQUIRE n.code IS UNIQUE
  - CREATE CONSTRAINT constraint_Condition_id IF NOT EXISTS FOR (n:Condition) REQUIRE n.code IS UNIQUE
  - CREATE CONSTRAINT constraint_CarePlan_id IF NOT EXISTS FOR (n:CarePlan) REQUIRE n.id IS UNIQUE
  - CREATE CONSTRAINT constraint_Speciality_id IF NOT EXISTS FOR (n:Speciality) REQUIRE n.name IS UNIQUE
  - CREATE CONSTRAINT constraint_Allergy_id IF NOT EXISTS FOR (n:Allergy) REQUIRE n.code IS UNIQUE
  - CREATE CONSTRAINT constraint_Address_id IF NOT EXISTS FOR (n:Address) REQUIRE n.address IS UNIQUE
  - CREATE CONSTRAINT constraint_Procedure_id IF NOT EXISTS FOR (n:Procedure) REQUIRE n.code IS UNIQUE

loading_queries:
  nodes:
    Payers:
      # skip: true
      file: payers.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MERGE (p:Payer {id:row.Id})
        SET p.name=row.NAME,
          p.address=row.ADDRESS,
          p.city=row.CITY,
          p.zip=row.ZIP,
          p.state=row.STATE_HEADQUARTERED

    # create Encounter, add end date if exists, merge in patient and relate,
    # merge in Organizations if exist and relate. relate to payer
    # class: ["ambulatory", "emergency", "home", "hospice", "inpatient", "outpatient", "snf", "urgentcare", "virtual", "wellness"]
    Encounters:
      # skip: true
      file: encounters.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MERGE (e:Encounter {id:row.Id})
          SET e.code=row.CODE,
            e.description=row.DESCRIPTION,
            e.class=row.ENCOUNTERCLASS,
            e.date=datetime(row.START),
            e.baseCost=toFloat(row.BASE_ENCOUNTER_COST),
            e.claimCost=toFloat(row.TOTAL_CLAIM_COST),
            e.coveredAmount=toFloat(row.PAYER_COVERAGE),
            e.reasonDescription=row.REASONDESCRIPTION,
            e.isEnd=false
        FOREACH (ignore in CASE WHEN row.STOP IS NOT NULL AND row.STOP <> '' THEN [1] ELSE [] END |
          SET e.end=datetime(row.STOP)
        )
        MERGE (p:Patient {id:row.PATIENT})
        MERGE (p)-[:HAS_ENCOUNTER]->(e)
        FOREACH (ignore in CASE WHEN row.ORGANIZATION IS NOT NULL AND row.ORGANIZATION <> '' THEN [1] ELSE [] END |
          MERGE (o:Organization {id: row.ORGANIZATION})
          MERGE (e)-[:HAS_ORGANIZATION]->(o))
        FOREACH (ignore in CASE WHEN row.PROVIDER IS NOT NULL AND row.PROVIDER <> '' THEN [1] ELSE [] END |
          MERGE (pr:Provider {id: row.PROVIDER})
          MERGE (e)-[:HAS_PROVIDER]->(pr))
        WITH e,row
        MATCH (pa:Payer {id:row.PAYER})
        MERGE (e)-[:HAS_PAYER]->(pa)

    # may add providers not included in encounters.csv
    Providers:
      # skip: true
      file: providers.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MERGE (p:Provider {id: row.Id})
        SET p.name=row.NAME,
            p.speciality=row.SPECIALITY
        MERGE (o:Organization {id: row.ORGANIZATION})
        MERGE (p)-[:BELONGS_TO]->(o)
        MERGE (a:Address {address: row.ADDRESS})
        SET a.location = point({latitude:toFloat(row.LAT), longitude:toFloat(row.LON)})
        MERGE (p)-[:HAS_ADDRESS]->(a)

    Patients:
      # skip: true
      file: patients.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MERGE (p:Patient {id:row.Id})
        SET
          p.birthDate=datetime(row.BIRTHDATE),
          p.deathDate=row.DEATHDATE,
          p.firstName=row.FIRST,
          p.lastName=row.LAST,
          p.SSN=row.SSN,
          p.marital=row.MARITAL,
          p.gender=row.GENDER,
          p.race=row.RACE,
          p.ethnicity=row.ETHNICITY,
          p.city=row.CITY
        MERGE (a:Address {address: row.ADDRESS})
        SET a.location = point({latitude:toFloat(row.LAT), longitude:toFloat(row.LON)})
        MERGE (p)-[:HAS_ADDRESS]->(a)

    PayerTransitionRels:
      # skip: true
      file: payer_transitions.csv
      query_v2: |
        WITH $rows as rows UNWIND rows as row
        MATCH (p:Patient {id:row.PATIENT})
        MATCH (payer:Payer {id:row.PAYER})
        MERGE (p)-[s:INSURANCE_START {year:datetime(row.START_DATE)}]->(payer)
        MERGE (p)-[e:INSURANCE_END {year:datetime(row.END_DATE)}]->(payer)
      query_v1: |
        WITH $rows as rows UNWIND rows as row
        MATCH (p:Patient {id:row.PATIENT})
        MATCH (payer:Payer {id:row.PAYER})
        MERGE (p)-[s:INSURANCE_START {year:toInteger(row.START_YEAR)}]->(payer)
        MERGE (p)-[e:INSURANCE_END {year:toInteger(row.END_YEAR)}]->(payer)

    Allergies:
      # skip: true
      file: allergies.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MATCH (p:Patient {id:row.PATIENT})
        MERGE (a:Allergy {code:row.CODE})
        SET a.description=row.DESCRIPTION
        MERGE (as:Encounter {id:row.ENCOUNTER})
        ON CREATE
          SET as.date=datetime(row.START), as.code=row.CODE, as.class='assertfalse'
        ON MATCH
          SET as.code=row.CODE
        MERGE (p)-[:HAS_ENCOUNTER]->(as)
        MERGE (as)-[:HAS_ALLERGY]->(a)
        WITH p,a,as,row
        WHERE row.STOP IS NOT NULL and row.STOP <> ''
        MERGE (ae:EncounterEnd {id:row.ENCOUNTER})
          SET ae.date=datetime(row.STOP), ae.code=row.CODE, ae.isEnd=true
        MERGE (as)-[:HAS_END]->(ae)

    Conditions:
      # skip: true
      file: conditions.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MATCH (p:Patient {id:row.PATIENT})
        MERGE (c:Condition {code:row.CODE})
        SET c.description=row.DESCRIPTION
        MERGE (cs:Encounter {id:row.ENCOUNTER})
        ON CREATE
          SET cs.date=datetime(row.START), cs.code=row.CODE, cs.class='assertfalse'
        ON MATCH
          SET cs.code=row.CODE
        MERGE (p)-[:HAS_ENCOUNTER]->(cs)
        MERGE (cs)-[:HAS_CONDITION]->(c)
        WITH p,c,cs,row
        WHERE row.STOP IS NOT NULL and row.STOP <> ''
        MERGE (ce:EncounterEnd {id:row.ENCOUNTER})
          SET ce.date=datetime(row.STOP), ce.code=row.CODE, ce.isEnd=true
        MERGE (cs)-[:HAS_END]->(ce)

    Medications:
      # skip: true
      file: medications.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MERGE (p:Patient {id:row.PATIENT})
        MERGE (d:Drug {code:row.CODE})
        SET d.description=row.DESCRIPTION, d.reasonDescription=row.REASONDESCRIPTION
        MERGE (ps:Encounter {id:row.ENCOUNTER})
        ON CREATE
          SET ps.code=row.CODE, ps.date=datetime(row.START), ps.class='assertfalse'
        ON MATCH
          SET ps.code=row.CODE
        MERGE (p)-[:HAS_ENCOUNTER]->(ps)
        MERGE (ps)-[:HAS_DRUG]->(d)
        WITH p,d,ps,row
        WHERE row.STOP IS NOT NULL and row.STOP <> ''
        MERGE (pe:EncounterEnd {id:row.ENCOUNTER})
          SET pe.date=datetime(row.STOP), pe.code=row.CODE, pe.isEnd=true
        MERGE (ps)-[:HAS_END]->(pe)

    Procedures:
      # skip: true
      file: procedures.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MERGE (p:Patient {id:row.PATIENT})
        MERGE (r:Procedure {code:row.CODE})
        SET r.description=row.DESCRIPTION
        MERGE (pe:Encounter {id:row.ENCOUNTER})
        ON CREATE
          SET pe.date=datetime(row.START), pe.code=row.CODE, pe.class='assertfalse'
        ON MATCH
          SET pe.code=row.CODE
        MERGE (p)-[:HAS_ENCOUNTER]->(pe)
        MERGE (pe)-[:HAS_PROCEDURE]->(r)

    Observations:
      # skip: true
      file: observations.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        WITH row
        WHERE row.ENCOUNTER IS NOT NULL and row.ENCOUNTER <> ''
        WITH row, row.CODE as code, CASE row.TYPE WHEN 'text' THEN row.VALUE ELSE toFloat(row.VALUE) END as value
        WITH row, apoc.map.fromPairs([[code, value]]) as attr
        MATCH (p:Patient {id:row.PATIENT})
        MATCH (oe:Encounter {id:row.ENCOUNTER})
        MERGE (oe)-[:HAS_OBSERVATION]->(o:Observation)
        SET o += attr, o.description=row.DESCRIPTION, o.category=row.CATEGORY

    CarePlans:
      # skip: true
      file: careplans.csv
      compression: none
      skip_file: false
      query: |
        WITH $rows as rows UNWIND rows as row
        MATCH (p:Patient {id:row.PATIENT})
        MERGE (c:CarePlan {code:row.CODE})
        SET c.description=row.DESCRIPTION, c.reasonDescription=row.REASONDESCRIPTION
        MERGE (cs:Encounter {id:row.ENCOUNTER})
        ON CREATE
          SET cs.code=row.CODE, cs.date=datetime(row.START), cs.class='assertfalse'
        ON MATCH
          SET cs.code=row.CODE
        MERGE (p)-[:HAS_ENCOUNTER]->(cs)
        MERGE (cs)-[:HAS_CARE_PLAN]->(c)
        WITH p,c,cs,row
        WHERE row.STOP IS NOT NULL and row.STOP <> ''
        MERGE (ce:EncounterEnd {id:row.ENCOUNTER})
        SET ce.date=datetime(row.STOP), ce.code=row.CODE, ce.isEnd=true
        MERGE (cs)-[:HAS_END]->(ce)

    Organizations:
      # skip: true
      file: organizations.csv
      query: |
        WITH $rows as rows UNWIND rows as row
        MATCH (o:Organization {id:row.Id})
          SET o.name=row.NAME
        MERGE (a:Address {address: row.ADDRESS})
          SET a.location = point({latitude:toFloat(row.LAT), longitude:toFloat(row.LON)})
        MERGE (o)-[:HAS_ADDRESS]->(a)

post_ingest:
  # Create NEXT relationship between encounters of a patient
  # todo change first statement to return id(node)
  - |
    CALL apoc.periodic.iterate(
    'MATCH (p)-[:HAS_ENCOUNTER]->(e)
    WITH p, e
    ORDER BY p.id, e.date
    WITH p, collect(e) as encounters
    CALL {
      WITH p,encounters
      WITH p,encounters, encounters[1..] as nextEncounters
      UNWIND range(0,size(nextEncounters)-1,1) as index
      WITH p, encounters[index] as first, nextEncounters[index] as second
      RETURN first, second
    }
    RETURN first, second',
    'MERGE (first)-[:NEXT]->(second)',{});

  # Pre-compute patient counts for each Condition
  # todo change first statement to return id(node)
  - |
    CALL apoc.periodic.iterate('MATCH (c:Condition) RETURN c',
      'MATCH (c)<-[:HAS_CONDITION]-(:Encounter)<-[:HAS_ENCOUNTER]-(p:Patient)
      WITH c,count(p) AS NUM
      SET c.num=NUM', {}
      );

  # compute age of patient in each encountert
  - |
    CALL apoc.periodic.iterate(
      'MATCH (:Patient)-[r:HAS_ENCOUNTER]->() return id(r) as id',
      'MATCH (p)-[r]->(e) where id(r)=id WITH e, duration.inMonths(p.birthDate, e.date).months / 12 AS age
       SET e.patientAge=age',
      {}
    )

  # # todo embedding
  # - |
  #   MATCH (v:Verbatim)
  #     WHERE v.verbatim <> ''
  #   WITH collect(v) AS verbatimList,
  #       count(*) AS total,
  #       100 AS batchSize
  #   UNWIND range(0, total, batchSize) AS batchStart
  #   CALL {
  #     WITH verbatimList,
  #       batchStart,
  #       batchSize
  #     WITH verbatimList,
  #       batchStart,
  #       [v IN verbatimList [batchStart .. batchStart + batchSize] |'Vehicle: '|| v.make + ' ' + v.model ||' | Category: '|| [(v)-[:HAS_CATEGORY]->(c:Category) | c.id][0] ||' | Problem: '||[(v)-[:HAS_PROBLEM]->(p:Problem) | p.problem][0] || ' | Question: ' ||[(v)-[:HAS_QUESTION]->(q:Question) | q.question][0] ||' | Survey Verbatim Response: '||v.verbatim] AS batch
  #     CALL genai.vector.encodeBatch(batch, 'OpenAI', { token: $key }) YIELD index, vector
  #     CALL db.create.setNodeVectorProperty(verbatimList[batchStart + index], 'adaEmbedding', vector)
  #   } IN TRANSACTIONS OF 1 ROW
